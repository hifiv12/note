  - 배열
    * 인덱스와 이에 대응하는 데이터로 이뤄진 자료구조
      - 인덱스를 이용해같은 타입의 데이터들을 순차적으로 저장
      - 반복문을 이용해 처리하기 적합
    * 배열 인덱스
      - 0부터 시작
    * 배열의 선언 및 생성
      - type [] var_name = new type[index]; 
      - type var_name p[] = new type[index];
    * 배열 원소 접근 
      - var_name[index_number]로 접근
      - 인덱스의 범위를 넘어가면 오류
    * 하나의 배열을 다수의 레퍼런스가 참조 가능 
      - 기존에 먼저 선언해놓은 레퍼런스 변수의 주소값을 가지고 있는데 다른 변수들이 그 주소값을 참조
    * 배열은 자바에서 객체의 관리
      - length
    * for-each문
      - 배열의 각 우너소를 순차적으로 접근하는데 유용함
      - for (int i : reference_var_name) {}
    * 2차원 배열
      - 선언 및 생성 
        * type var_name[][] = new type[n][m];
        * type [][] var_name = new type[n][m]; 
      - length
        * 행의 개수는 n개 
        * var_name[n].length -> 열의 m-1개수
    * 정방형과 비정방형 배열
      - 행이 순차적으로 지나감에 따라 열의 개수가 특정 규칙에 의해 일정하게 늘어나는것 
    * 메소드에서 배열 리턴
      ```java
        type[] makeArray() {
          type temp[] = new type[4];
          return temp;
        }        
      ```
  - main() 메소드
    * 자바 응용프로그램의 실행 시작 메소드
    * main()의 원형
      - public static void main(String[] args) {}
      - 매개변수가 존재하는 이유는 terminal에서 컴파일 할때 전달해줄 수 있다.
  
---------------------------------------------------------------------------

  - 자바의 예외처리
    * 컴파일 오류
      - 문법에 맞지 않게 작성된 코드
      - 컴파일 할 때 발견
    * 예외(Exception)
      - 오동작이나 결과에 악영향을 미칠 수 있는 실행 중 발생한 오류
      - 자바에서 예외 처리 가능
        * 예외 발생 -> 자바 플랫폼 인지 -> 응용 프로그램에서 전달
    * 예외 처리, try-catch-finally문
      - 예외가 발생할 때 대응하는 응용프로그램 코드
      - try-catch-finally 사용

      ```java
        try {
          //예외가 발생할 가능성이 있는 실행문
        } catch (/*처리할 예외 타입선언*/) {
          //예외 처리문
        } finally {
          //예외 발생 여부와 상관없이 무조건 실행되는 문장
        }
      ````

    * 자주 발생하는 예외

      예외 타입(예외 클래스) | 예외 발생 경우 | 패키지
      -- | -- | --
      ArithmeticException | 정수를 0으로 나눌 떄 발생 | java.lang
      NullPointerException | null 레퍼런스를 참조할 때 발생 | java.lang
      ClassCastException | 변환할 수 없는 타입으로 객체를 변환할 때 발생 | java.lang
      OutofMemoryError | 메모리가 부족한 경우 발생 | java.lang
      ArrayIndexOutOfBoundsException | 배열의 범위가 벗어난 접근 시 발생 | java.lang
      IllegalArgumentException | 잘못된 인자 전달 시 발생 | java.lang
      IOException | 입출력 동작 실패 또는 인터럽트 시 발생 | java.io
      NumberFormatException | 문자열이 나타내는 숫자와 일치하지 않는 타입의 숫자로 변환시 발생 | java.lang
      InputMismatchException | Scanner 클래스의 nextInt()를 호출하여 정수로 입력 받고자 했지만 사용자가 'a' 등과 같이 문자를 입력한 경우 | java.util

----------------------------------------------------------------------------------------

4. 클래스와 객체
  - 세상 모든 것이 객체
    * 실세계 객체의 특징 : 고유한 특성(state)와 행동(behavior)을 가짐
    * 다른 객체들과 정보소통 및 상호작용하며 존재 
    * 프로그램 에서의 객체 : 테트리스 블록
  - 객체 지향의 특성 : 캡슐화
    * 캡슐화 : 객체의 캡슐로 싸서 내부를 못보게 하는것
      - 외부의 접근으로 부터 객체 보호
  - 자바의 캡슐화
    * 클래스
      - 객체 모양을 선언한 틀(캡슐화)
      - 메소드(멤버 함수)와 필드(멤버 변수)는 모두 클래스 내에 구현
    * 객체
      - 클래스의 모양대로 생성된 실체(instance)
      - 객체 내 데이터에 대한 보호, 외부 접근 제한
  - 객체 지향의 특성 : 상속
    * 상속
      - 상위 개체의 속성이 하위 개체에 물려짐
      - 하위 객체가 상위 개체의 속성을 모두 가지는 관계
    * 실사례
      - 유전적 상속 관계
  - 자바의 상속 
    * 상속
      - 자식 클래스가 부모 클래스의 속성 물려받고, 기능 확장
        * 부모 클래스 : super class
        * 하위 클래스 : sub class, 부모 클래스를 재사용 및 새로운 특성 추가
        * extends 키워드 사용 -> class sub_name extends sup_name {}
  - 객체 지향의 특성 : 다형성
    * 다형성
      - 같은 이름의 메소드가 클래스나 객체에 따라 다르게 동작하도록 구현
      - 사례 
        * 메소드 오버로딩 : 같은 이름이지만 다르게 작동하는 여러 메소드
        * 메소드 오버라이딩  : 슈퍼클래스의 메소드를 서브 클래스마다 다르게 구현, 이름과 매개변수가 같다.
  - 객체 지향 언어의 목적
    * 소프트 웨어 생산성 향상
    * 실세계에 대한 쉬운 모델링
  - 절차 지향 프로그래밍과 객체 지향 프로그래밍
    * 절차 지향 프로그래밍
      - 작업 순서 표현
      - 작업을 함수로, 작성한, 함수들의 집합
    * 객체 지향 프로그래밍
      - 객체들간의 상호 작용으로 표현
      - 클래스 혹은 객체들의 집합으로 프로그램 작성

  - 클래스와 객체 
    * 클래스 : 틀
    * 객체 : 실체(instance)
    * 사례 : 클래스(붕어빵 틀) > 객체(붕어빵)

-----------------------------------------------------------------------------

  - 클래스 구성
    ```java
    public class Circle { // 접근_권한 클래스_선언 클래스_이름
      public int radius; // 원의 반지름 필드
      public String name; // 원의 이름 필드
      
      public Circle() { // 원의 생성자 메소드

      }
      public double getArea() { // 원의 면적 계산 메소드
        return 3.14 * radius * radius;
      }
    }
    ```

  - 클래스 구성 설명 for class Circle
    * 클래스 선언 : class Circle
    * 필드와 메소드 : 객체 내 데이터 저장하는 멤버 변수, 제어하는 멤버 함수 
    * 필드의 접근 지정자 : 다른 클래스의 접근 허용을 표시
    * 생성자 : 객체 생성시 자동으로 호출되는 메소드
  - 객체 생성
    * new 키워드를 이용하여 생성
  - 객체 생성 과정
    * 객체의 레퍼런스 변수 선언
    * 객체 생성
      - 클래스 타입 크기의 메모리 할당
      - 객체 내 생성자 코드 실행
    * 객체의 멤버 접근

------------------------------------------------------------------------

  - 생성자 개념
    * 생성자 : 객체가 생성될 때 초기화를 위해 실행되는 메소드
  - 생성자의 특징
    * 생성자는 메소드
    * 이름은 클래스 이름과 동일
    * 생성자 여러개 작성 가능 (오버로딩)
    * new를 통해 객체 생성 시 객체당 한번 호출
    * 리턴 타입 지정불가
    * 목적은 객체 초기화
  - 기본 생성자
    * 디폴트 생성자 
    * 클래스에 생성자가 하나도 선언되지 않을 경우, 컴파일러에 의해 자동으로 삽입
  - this 레퍼런스
    * this : 객체 자신에 대한 레퍼런스
    * this.var_name 
    * this의 필요성
      - 객체의 멤버 변수와 메소드 변수의 이름이 같은 경우
      - 다른 메소드 호출 시 객체 자신의 레퍼런스를 전달할 때
      - 메소드가 객체 자신의 레퍼런스를 반환할 때
    * this() 다른 생성자 호출
      - 클래스 내의 다른 생성자 호출
      - 생성자 내에서만 사용가능
      - 반드시 생성자 코드의 제일 처음에 수행
  - 객체의 치환
    * 객체가 복사되는게 아닌 레퍼런스가 복사
  - 객체 배열
    * 객체 배열 생성 및 사용
    ```java
    Circle [] c; // Circle 배열에 대한 레퍼른스 변수 c선언
    c = new Circle[5]; // 레퍼런스 배열 생성

    for (int i=0; i<c.length; i++) {
      c[i] = new Circle(i); // 배열의 각 원소 객체 생성
    }

    for(int i=0; i<c.length; i++) { // 배열에 있는 모든 Circle 객체의 면적 출력
      System.out.print((int)(c[i].getArea()) + " "); // 배열의 원소 객체 사용
    }
    ```

------------------------------------------------------------------------------

  - 메소드 
    * 메소드 : 클래스의 멤버 함수, 반드시 클래스 안에 있어야 된다.
    * 구성형식 
      - 접근 지정자
      - 리턴 타입
    * 인자 전달
      - case1 : 기본 타입의 값 전달 > 값 복사 > 실인자 값은 변경안됨
      - case2 : 객체 혹은 배열 전달 > 레퍼런스 전달 > 공유의 형태라서 실인자 값이 바뀜
  - 메소드 오버로딩
    * 이름이 같은 메소드 작성
      - 매개변수의 개수나 타입이 서로 다름
      - 이름이 동일한 메소드
      - 리턴 타입은 오버로딩과 관련 없음
  
  - 객체의 소멸과 가비지 컬렉션
    * 객체 소멸 : new에 의해 할당된 객레 메모리를 자바 가상 기계의 가용 메모리로 되돌려 주는 행위
    * 자바 응용프로그램에서 임의로 객체 소멸할 수 없음  
    * 가비지 
      - 가르키는 레퍼런스가 하나도 없는 객체
    * 가비지 컬렉션
      - 자바 가상 기계의 가비지 컬렉터가 자동으로 기비지 수집 반환
      - 가비지 컬렉션 스레드에 의해 수행
      - 개발자에 의한 강제 가비지 컬렉션이 존재
        * System.gc(); // 가비지 컬렉션 호출

-------------------------------------------------

  - 접근 지정자 이해
    * 패키지  
      - 관련 있는 클래스 파일을 저장하는 디렉토리
      - 자바 응용프로그램은 하나 이상의 패키지로 구성
    * 자바의 접근지정자
      - prrivate : 내부
      - default : 동일패키지까지 허용
      - protected : 동일 패키지와 자식 클래스에 허용
      - public : 모든 클래스에 허용
    * 접근 지정자의 목적
      - 클래스나 일부 멤버를 공개하여 다른 클래에서 접근하도록 허용
      - 객체 지향 언어의 캡슐화 정책은 멤버를 보호하는 것
  - 클래스 접근 지정
    * 다른 클래스에서 사용하도록허용할 지 지정
    * public 클래스
    * default 클래스 (접근지정자 생략)
      - package-private
      - 같은 패키지의 클래스에만 접근 허용
  - 멤버 접근 지정
    * public 멤버 : 패키지에 관계없이 모든 클래스에 접근 허용
    * private 멤버 : 동일 클래스에서만 접근가능. 상속 받은 서브 클래스에서는 불가
    * protected 멤버 : 같은 패키지 내의 다른 모든 클래스 접근 허용, 상속 서브 클래스 다른 패키지에 있어도 가능
    * default 멤버 : 같은 패키지 내의 다른 클래스에게 접근 허용

    멤버에 접근하는 클래스 | private | default | protected | public
    -- | -- | -- | --
    같은 패키지의 클래스 | X | O | O | O 
    다른 패키지의 클래스  | X | X | X | O
    접근 가능 영역  | 클래스 내 | 동일 패키지 내 | 동일 패키지와 자식 클래스 | 모든 클래스


--------------------------------------------------------------------

int i[];

int[] i ;
  -> i는 reference 변수, i에 저장될 참조값을 이용해서 데이터에 접근. 참조하는 데이터는 int형 배열
  -> i는 배열의 이름, 배열의 이름은 reference 변수이다.

reference 변수에는 reference값만 저장

enumeration 열거형
  -> 새로운 자료형을 만드는 것 
  -> 사용자 정의 자료형

배열이나 pl/sql의 리턴값은 1개이다.

1.실행시에 에러가 안나다가 에러가 나는 케이스가 발생할 때 runtime error
2.프로그램이 갑자기 멈춤

Exception
  : 실행 중에 갑자기 발생하는 에러
  -> 예외가 발생하면 응용프로그램이 종료됨
  -> c에서는 개발자가 runtime error를 예측해서 직접 예외처리
  : 숙련된 개발자가 아니면 놓치는 경우가 많음
  -> java에서는 예외처리를 jvm에 직접처리
  : 예외가 발생해도 응용프로그램이 종료되지 않음
  : 신뢰성 높은 응용프로그램 제작 가능

JAVA의 주요특징
1.JVM
2.Exception처리
3.가비지콜렉터
4.멀티쓰레드