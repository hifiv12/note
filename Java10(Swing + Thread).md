  - JButton
    * 새로운 버튼 만들기 상속받아


13. 스레드와 멀티태스킹
  - 멀티태스킹
    * 하나의 응용 프로그램이 여러 개의 작업을 동시에 처리
  
  - 스레드
    * 사용자가 작성한 코드로서 jvm에 의해 스케쥴링되어 실행되는 단위
    * 자바의 멀티태스킹
      + 멀티스레딩만 가능, 하나의 응용프로그램은 여러 개의 스레드로 구성
    * 효과
      + 스레드1 이 대기하는 동안 스레드2가 실행
      + 프로그램 전체적으로 시간 지연을 줄임
    * 웹 서버의 멀티스레딩 
      + 웹서버 스레드가 웹 서비스 스레드를 각 웹 클라이언트 맞게 생성
    
  - 자바 스레드(Thread)
    * 스레드의 생명 주기는 JVM에 의해 관리됨
    * 하나의 JVM은 하나의 자바 응용프로그램만 실행
    * 하나의 응용프로그램은 하나 이상의 스레드로 구성 가능

  - 자바에서 스레드 생성방법
    * 스레드를 생성하고 스레드 코드를 실행토록 JVM에게 요청
      + java.lang.Thread 클래스
      + java.lang.Runnable 인터페이스
  
  - 클래스를 이용한 스레드
    * 클래스 상속 
    * run() 메소드 override
    * 객체 생성
    * .start() 호출
    * run() 메소드가 종료하면 스레드는 종료
    * 한번 종료한 스레드는 다시 시작시킬 수 없다.
    * 한 스레드에서 다른 스레드를 강제 종료할 수 있다.

  - 스레드 정보
    
    필드 | 타입 | 내용
    -- | -- | --
    스레드 이름 | 스트링 | 스레드의 이름으로서 사용자가 지정
    스레드 ID | 정수 | 스레드 고유의 식별자 번호
    스레드 PC(Program Count) | 정수 | 현재 실행 중인 스레드 코드의 주소
    스레드 상태 | 정수 | NEW, RUNNABLE, WAITING, TIMED_WAITING, BLOCK, TERMINATED
    스레드 우선 순위 | 정수 | 스레드 스케줄링 시 사용되는 우선순위 값 min 1 ~ 10 max
    스레드 그룹 | 정수 | 여러 개의 자바 스레드가 하나의 그룹을 형성할 수 있으며이 경우 스레드가 속한 그룹
    스레드 레지스터 스택 | 메모리 블록 | 스레드가 실행되는 동안 레지스터들의 값

  - 스레드 상태 -> JVM이 기록관리
    * NEW
      + 생성, 아직 실행할 준비는 안됨
    * RUNNABLE
      + 실행 또는 스케쥴링 기다리는 상태
    * WAITING
      + wait() 호출한 상태
      + 스레드 동기화를 위해 사용
    * TIMED_WAITING
      + sleep(n)을 호출 n 밀리초 동안 잠자고 있는 상태
    * BLOCK
      + 스레드가 I/O 작업 요청 -> JVM이 자동으로 BLOCK 상태로 전환
    * TERMINATED
      + 스레드가 종료한 상태
  
  - 스레드 우선순위와 스케쥴링
    * 1 ~ 10 -> 1: min, 5:normal, 10:max
    * setPriority(int n) -> 사용해 변경가능
    * main() -> 5
    * 스레드는 부모 스레드와 동일한 우선 순위 값을 가지고 생성
    * 철저한 우선순위 기반
      + 동일한 우선순위 스레드는 돌아가면서 스케쥴링 (round-robin)
  
  - main() 실행하는 main Thread
    * JVM 응용 프로그램을 시작하면 main Thread 실행
    * 종료되면 같이 종료

  - 스레드의 종료 
    * run( return; ) : 스스로 종료
    * interrupt() : 타 스레드 강제종료 
    * flag (boolean?) false를 돌려서 run 메소드 안 return하는 구조

  - 스레드 동기화(Thread Synchronization)
    * 다수의 스레드가 공유 데이터에 동시에 접근하는 경우
      + 값이 예상치 못한 결과가 발생할 가능성이 존재
    * 공유 데이터를 접근하는 모든 스레드를 한줄로 세워야됨
      + 스레드1이 공유 데이터 작업이 끝날떄 까지 다른 스레드는 대기

  - 스레드 동기화 기법
    * 공유 데이터에 동시에 접근하는 다수의 스레드가 공유 데이터를 배타적으로 접근하기 위해 상호 협력하는것
    * __스레드의 공유 데이터에 대한 배타적 독접 접근 보장__
    * synchronized로 동기화 블록 지정
    * wait()-notify() 메소드로 스레드 실행 순서 제어 

  - synchronized 블럭
    * 한 스레드가 독점 실행해야 하는 부분을 표시하는 키워드
      + 메소드 혹은 코드 블럭
    * 컴파일러의 처리
      + 먼저 실행한 스레드가 모니터 점유
        - 모니터란 해당 객체를 독점적으로 사용할 수 있는 권한
      + 모니터를 점유한 스레드가 내려놓기전까지 다른 스레드 대기

  - prodecer-consumer 문제와 동기화
    * producer : 공유 메모리에 데이터를 공급하는 스레드 
    * consumer : 소비하는 스레드
      + 동시에 접근하는 문제

  - 동기화
    * 동기화 객체 : 두개 이상의 스레드 동기화에 사용되는 객체
    * 메소드
      + wait() : 다른 스레가 notify() 호출전까지 대기
      + notify() : wait()를 호출하여 대기중인 스레드를 꺠우기 RUNNABLE 상태로 만듦. 오직 한 스레드만
      + notifyAll() : wait()을 호출해 대기중인 모든 스레드를 깨우고 RUNNABLE로 만든다
      + synchronized 블록 내애서만 사용

14. 고급 스윙 컴포넌트
  - 메뉴
    * JMenuBar
    * JMenu
    * JMenuItem
    * action 익명함수 이용가능

  - 툴바
    * 여러 콤포넌트를 담을 수 있는 컨테이너
    * borrderLayout배치관리자를 가진 컨테이너만 부착
    * JToolBar.setFloatable(boolean b)
    * JToolBar.addSeparator()

  - 툴팁
    * 스윙 컴포넌트를 설명하는 팁 문구
    * JComponent.setToolTipText(String msg)    



--------------------------------------------------------
4,5,7,13

멀티 Thread
  -> 동시에 여러개의 쓰레드가 서로 다른 작업을 실행

자바 응용프로그램은 main()이 실행되면 자동으로 main thread가 생성됨

순서대로 작업하는 것이 아니기 때문에 어떤 쓰레드의 작업이 먼저 끝날지 알 수 없음
  -> 일반적으로 Thread는 무한루프 작업을 마니함
  -> 우선순위가 같은 thread들은 무한루프 작업을 하는 동안 전체적으로 같은 비율로 처리됨

CPU 1개
  -> A thread 작업을 진행하다가 B thread 작업을 진행, 다시 A 작업으로 동작

CPU 1개 Core가 n개
  -> Core가 서로 다른 작업 가능

Thread 동기화
  : 멀티 스레드 상태에서 공유 메모리를 서로 접근하여 데이터가 꺠지지 않도록 공유메모리에 접근하는 순서대로 처리

Synchronize 동기화
Asynchronize 비동기화

Ajax (Asynchronous javasciprt and xml) 
  비동기 자바스크립트와 xml을 사용한 기술