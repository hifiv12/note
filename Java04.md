  - static 
    * non-static 멤버
      - 멤버들은 독립적 별도 존재
      - 필드와 메소드는 객체 생성 후 사용가능
      - 다른 객체에 의해 공유되지 않고 배타적
    * static 멤버
      - 클래스당 하나만 생성
      - 객체를 생성하지 않고 사용가능
      - 특성
        * 클래스당 하나만 생성
        * 클래스가 로딩될 때 공간 할당
        * 동일한 클래스의 모든 객체에 의해 공유

    -- | non-static 멤버 | static 멤버
    -- | -- | --
    공간적 특성 | 멤버는 객체마다 별도 존재 -> 인스턴스 멤버 | 멤버는 클래스당 하나 생성 -> 객체 내부가 아닌 별도의 공간에 생성 -> 클래스 멤버
    시간적 특성 | 객체 생성 시에 멤버 생성됨 -> 객체가 생길 때 멤버도 생성, 객체 생성 후 멤버 사용 가능, 객체가 사라지면 멤버도 사라짐 | 클래스 로딩시 멤버 생성, 객체 생성 전 이미 생성 및 사용 가능, 프로그램 종료시 사라짐 
    공유의 특성  | 공유되지 않음 > 객체 내의 각각 공간 유지 | 동일한 클래스의 모든 객체들에 의해 공유

        * 선언 
      ```java
        class Sample {
          int n;
          void g() {...}
        }
      ``` 

      ```java
        class Sample {
          static int m,
          static void f() {...}
        }
      ```

  - static의 활용
    * 전역 변수와 전역 함수를 만들 때 활용
      - Math 클래스의 모둔 필드와 메소드가 public static으로 선언
    * 공유 멤버를 작성할 때
      - static 필드나 메소드는 하나만 생성. 클래스의 객체들 공유
  - static 메소드의 제약 조건 
    * static 메소드는 non-static 멤버 접근할 수 없음
    * static 메소드는 this 사용불가 -> 객체 생성 전에 reference가 없음

  - final 클래스와 메소드
    * 특징
      - 클래스 상속 불가
      - 오버라이딩 불가
    * 필드, 상수 선언 특징
      - 상수 선언시 사용
        ```java
          class SharedClass {
            public static final double PI = 3.14;
          }
        ```
      
      - 상수 필드는 선언 시 초기 값을 지정하여야 한다
      - 상수 필드는 실행 중에 값을 변경할 수 없다 

5. 상속
  - 상속
    * 객체 지향의 상속
      - 부모 클래스의 필드, 메소드를 자식 클래스가 물려받음
    * 상속을 통해 간결한 자식 클래스 작성

  - 객체 지향에서 상속의 장점
    * 클래스의 간결화
      - 멤버의 중복 작성 불필요
    * 클래스관리 용이
      - 클래스들의 계층적 분류
    * 소프트웨어의 생산성 향상
      - 클래스 재사용과 확장 용이
      - 새로운 클래스의 작성 속도 빠름

  - 클래스 상속과 객체
    * 자바의 상속 선언 : extends 키워드 사용
      - 부모 클래스 > super class
      - 자식 클래스 > sub class

  - 자바 상속의 특징
    * 클래스의 다중 상속 지원하지 않음
    * 상속 횟수 무제한
    * 상속의 최상의 조상 클래스는 java.lang.Object

  - 상속과 접근 지정자
    * public 
      - 패키지, 클래스 위치 상관 없이 접근 허용
    * protected 
      - 같은 패키지, 모든 클래스 허용
      - 다른 패키지, 서브클래스(패키지1)는 슈퍼클래스(패키지2)의 protected멤버 접근 가능
    * default 
      - 같은 패키지, 모든 클래스 허용
    * private
      - 클래스 내에서만 접근 허용
    
  - 서브 클래스/슈퍼클래스의 생성자 호출 및 실행
    * new에 의해 서브 클래스 객체가 생성
      - 슈퍼 클래스 생성자와 서브 클래스 생성자 모두 실행
      - 호출 및 실행
        * sub class call > super class call > super class constructor() > sub class constructor()
  
  - 서브 클래스에서 슈퍼 클래스의 생성자 선택
    * 슈퍼 클래스와 서브 클래스 각각 여러 생성자 작성 가능
    * 서브 클래스 생성자에서 슈퍼 클래스 생성자 하나 선택
    * 서브 클래스에서 슈퍼 클래스 생성자 선택 안함 > 컴파일러가 자동 선택
    * 서브 클래스에서 슈퍼 클래스 생성자 선택 방법 > super()이용

  - 업스캐팅(upcasting)
    * sub class를 super class 타입으로 변환
      - 변환된 클래스는 super class의 멤버만 접근 가능
  
  - 다운캐스팅(downcasting)
    * super class를 sub class 타입으로 변환
      - 변환 시 (sub_type) 타입변환 표시 필요
      - subclass의 멤버도 접근 가능

  - instanceof 연산자와 객체의 타입 판단
    * 업캐스팅된 레퍼런스로 객체의 타입 판단이 어려움
      - 슈퍼클래스는 여러 서브 클래스에 상속이 되기에
    * instanceof 연산자
      - 레퍼런스가 가리키는 객체의 타입 식별을 위해 사용
      - ojbect_reference instanceof class_type 
        * return은 boolean

  - 메소드 오버라이딩
    * 슈퍼 클래스의 메소드를 서브 클래스에서 재정의
      - 메소드 이름, 매개변수 타입 및 개수, 리턴 타입등 모든 것을 동일하게 작성
      - 메소드 무시하기, 덮어쓰기로 번역되기도 함
      - 동적 바인딩 -> 서브 클래스에 오버라이딩 된 메소드가 무조건 실행
        * 만약 슈퍼클래스를 업캐스팅을 하면 기존의 메소드가 아닌 자식 클래스의 오버라이딩된 메소드가 호출
  
  - 오버라이딩의 목적, 다형성 실현
    * 오버라이딩
      - 슈퍼 클래스에 선언된 메소드를 각 서브 클래스들이 자신만의 내용으로 새로 구현하는 기능
      - 상속을 통해 하나의 인터페이스에 서로 다른 내용 구현이라는 객체 지향의 다형성 실현
      - 실행 시간 다형성 실현 > 동적 바인딩
    * 동적 바인딩
      - 실생할 메소드를 실행 시에 결정
      - 오버라이딩 메소드가 항상 호출


--------------------------------------------------------------------
객체 지향

객체지향 프로그래밍의 장점
1.대규모 프로젝트에 적합
  -> 클래스 안에 변수, 메소드가 묶여 있어서
  체계적인 분류, 관리가 용이
  -> 여러 사람이 협업 할 때도 편리
  대규모 도서관은 책을 체계적으로 분류해야 관리/운영이 편리하다.
2.상속을 이용해서 생산성 향상
  -> 오랜기간 프로그램을 version up하면서 사용할 경우
  상속을 활용하면 코드의 중복 방지, 유지보수에 도움

객체지향 프로그래밍의 단점
1.개발시간은 절차식프로그래밍보다 더 오래 거릴 수 있음
2.프로그램이 상댕적으로 무겁다(메모리)

TOC(Total Of Cost)
  : SW를 개발부터 운영, 유지보수 하다가 폐기하기까지의 총비용
  대규모 프로젝트의 경우 개발비용을 절약하는 것도 중요하지만 유지보수 비용을 절감하는 것도 매우 중요

SI(System Integrity) - 시스템 통합
  : 개발

SM(System Management) - 시스템관리/운영
  : 관리/운영

Class
  1.객체생성기
  2.사용자정의 데이터타입

Circle c; c 는 레퍼런수 변수이며 c에 저장된 참조값은 Circle class
  -> 인스턴스명은 레퍼런스 변수


this()로 다른 생성자 호출
  : 생성자가 오버로딩시 사용
  1.생성자에서 다른 생성자를 호출할 때 사용

기본타입 8개
String instance 배열의 이름은 레퍼런스 변수이다

메모리릭 (Memory Leak) - 메모리 누수
  : 사용하지 않느 ㄴ메모리가 소멸되지 않고 계속 남아 있게 되고 이런 사용하지 않는 메모리가 계속 늘어나면 결국 컴퓨터의 메모리를 더 사용하기 어렵게 된다.
  
  -> c에서는 개발자가 직접 메모리 누수가 나지 않도록 처리
  -> java에서는 가비지콜렉터가 가비지를 모아서 자동 소멸시킴

Circle[] c;
  : c는 레퍼런스 변수 이고 c에 저장될 레퍼런스를 따라가면 Circle의 배열이 있다.

인자 전달 방식
Call by value
call by reference
Call by address