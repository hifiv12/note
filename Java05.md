  - 오버라이딩과 super 키워드
    * super는 슈퍼 클래스의 멤버에 접근할 때 사용되는 레퍼런스 
    * 서브 클래스에서만 사용
    * 슈퍼 클래스의 메소드 호출
    * 컴파일러는 super의 접근을 정적 바인딩으로 처리
  
  - 오버라이딩과 오버로딩

    비교 요소 | 메소드 오버로딩 | 메소드 오버라이딩
    -- | -- | --
    선언 | 같은 클래스나 상속 관계에서 동일한 이름의 메소드 중복 작성 | 서브클래스에서 슈퍼 클래스에 있는 메소드와 동일한 이름의 메소드 작성
    관계 | 동일한 클래스 내 혹은 상속 관계 | 상속 관계
    목적 | 이름이 같은 여러 개의 메소드를 중복 작성하여 사용의 편리성 향상. 다형성 실현 | 슈퍼 클래스에 구현된 메소드를 무시하고 서브 클래스에서 새로운 기능의 메소드를 재정의하고자 함. 다형셩 실현
    조건 | 메소드 이름은 반드시 동일하고, 매개변수 타입이나 개수가 달라야 성립 | 메소드 이름, 매개변수 타입과 개수, 리턴 타입이 모두 동일하여야 성립
    바인딩 | 정적 바인딩, 호출될 메소드는 컴파일 시에 결정 | 동적 바인딩. 실행 시간에 오버라이딩된 메소드 찾아 호출

  - 추상 메소드와 추상 클래스
    * 추상 메소드(abstract method) 
      ```java
        public abstract String getName();
      ```
      - 선언되었지만 구현되지 않은 메소드 
      - 추상 메소드는 서브 클래스에서 오버라이딩 하여 구현
    * 추상 클래스의 2종류
      ```java
        abstract class Shape {}
      ```
      - 추상 메소드를 하나라도 가진 클래스
      - 추상 메소드가 하나도 없지만 abstract로 선언된 클래스
    * 추상 클래스는 객체를 생성할 수 없다.
    * 추상 클래스의 상속
      - 추상 클래스의 단순 상속
        * 추상 클래스를 상속 받아 추상 메소드를 구현하지 않으면 -> 추상클래스가 됨
        * 그래서 서브클래스도 abstract 선언
      - 추상 클래스의 구현 상속
        * 서브 클래스에서 슈퍼 클래스의 추상 메소드를 오버라이딩(구현) -> 클래스
    * 추상 클래스의 용도
      - 슈퍼 클래스에서는 개념 정의
        * 서브 클래스 마다 다른 구현이 필요한 메소드는 추상 메소드로 선언
      - 각 서브 클래스마다 구체적 행위 구현
        * 서브 클래스 마다 목적에 맞게 추상 메소드 다르게 구현
      - 계층적 상속 관계를 갖는 클래스 구조를 원할 때
  
  - 자바의 인터페이스
    * 인터페이스
      - 클래스가 구현해야 할 메소드들이 선언되는 추상형
        ```java
          public interface SerialDriver {...}
        ```
    * 인터페이스 버전별 변화
      - 7 : 인터페이스는 상수와 추상 메소드로만 구성
      - 8 : default
      - 9 : private, static

  - 인터페이스의 구성요소
    * 상수 
      - public만 허용 public static final 생략
    * 추상 메소드
      - public abstract 생략 가능
    * default 메소드
      - 인터페이스에 코드가 작성된 메소드
      - 인터페이스를 구현하는 클래스에 자동 상속
      - public 접근 지정만 허용 및 생략가능
    * private 메소드
      - 인터페이스 내에 메소드 코드가 작성됨
      - 인터페이스 내에 있는 다른 메소드에 의해서만 호출가능
    * static 메소드
      - public, private 모두 지정 가능 및 생략하면 public

  - 인터페이스 특징
    * 인터페이스 객체 생성 불가
    * 인터페이스 타입의 레퍼런스 변수 선언 가능
    * 인터페이스 구현
      - 구현 시 인터페이스 내 모든 추상메소드 반드시 구현
    * 다른 인터페이스 상속 가능
    * 다중 상속 가능

  - 인터페이스 구현
    * 인터페이스의 추상 메소드를 모두 구현한 클래스 

      ```java
        class SamsungPhone implements PhoneInterface {
          public void sendCall() {...};
          public void receivCall() {...};

          public void flash() {...};
        }
      ```

    * 다른 인터페이스 상속
      - extends 키워드 이용
      - 다중 인터페이스 상속
        * extends interface1, interface2, interface3
  
  - 인터페이스의 목적
    * 스펙을 주어 클래스들이 그 기능을 서로 다르게 구현할 수 있도록 하는 클래스의 규격 선언이며, 클래스의 다형성을 실현하는 도구이다.

  - 다중 인터페이스 구현
    * 클래스는 하나 이상의 인터페이스를 구현할 수 있음 
    * 클래스에서 인터페이스의 메소드를 구현할 때 public 생략하면 오류 발생?

  - 추상 클래스와 인터페이스 비교
    * 유사점
      - 객체를 생성할 수 없고, 상속을 위한 슈퍼 클래스로만 사용
      - 클래스의 다형성을 실현하기 위한 목적
    * 다른점

      비교 | 목적 | 구성
      -- | -- | --
      추상 클래스 | 추상 클래스는 서브 클래스에서 필요로 하는 대부분의 기능을 구현하여 두고 서브 클래스가 상속 받아 활용할 수 있도록 하되, 서브 클래스에서 구현할 수 밖에 없는 기능만을 추상 메소드로 선언하여, 서브 클래스에서 구현하도록 하는 목적 | 추상 메소드와 일반 메소드 모두 포함 / 상수 및 변수 필드 모두 포함
      인터페이스 | 인터페이스는 객체의 기능을 모두 공개한 표준화 문서와 같은 것으로, 개발제에게 인터페이스를 상속받는 클래스의 목적에 따라 인터페이스의 모든 추상 메소드를 만들도록 하는 목적 | 멤버변수는 포함하지 않음 / 상수 추상 메소드, 일반 메소드, default 메소드, static 메소드 모두 포함 / protected 접근 지정 선언 불가 / 다중 상속 지원

6. 모듈과 패키지 개념, 자바 기본 패키지 
  - 패키지 개념과 필요성
    * 디렉토리의 구분 없이 작업하면 동일명의 이름을 가진 확장자 끼리 서로 오류가 발생할 수 있다. 
    * 그래서 디렉토리로 각 개발자의 코드를 관리하는 것 -> 이름이 같더라도 경로가 다르기에 서로 다른 파일로 취급

  - 자바의 모듈(module)과 패키지(package)
    * 패키지 : 서로 관련된 클래스와 인터페이스의 컴파일 된 클래스 파일들을 하나의 디렉토리에 묶어놓은 것
    * 모듈 : 여러 패키지와 이미지 등의 자원을 모아 놓은 컨테이너
      - JDK9부터 자바 API의 모든 클래스들(자바 실행 환경)을 패키지 기반에서 모듈들로 완전히 재구성
      - 응용 프로그램 역시 여러 개의 모듈로 분할하여 작성 가능 
      - 목적
        * 자바 API를 여러 모듈(99개)로 분할하여 응용 프로그램의 실행에 적합한 모듈들로만 실행 환경을 구축할 수 있도록 함 
        * 메모리 등의 자원이 열악한 작은 소형기기에 꼭 필요한 모듈로 구성된 작은 크기의 실행 이미지를 만들기 위함
      - 현실
        * 복잡한 개념, 큰 자바 응용프로그램에는 개발 유지 보수등에 적합
    * 패키지명과 클래스의 경로명
      - Project.FileIO.Tools.class

  - 자바 API의 모듈 파일
    * JDK에 제공되는 모듈파일 > 자바 API의 패키지와 클래스가 들어 있음
    * Jmod 명령을 이용해 모듈 파일에 들어 있는 패키지를 풀어냄
  
  - 패키지 사용하기 
    * import 키워드를 통해 사용
    * 다른 패키지의 작성된 클래스 사용
      - import를 사용 안해도 불러올 수 있지만 전체 경로명을 써야 되기에 불편
      - import java.util.scanner;
      - import java.uitl.*;

  - 패키지 만들기 
    * package 패키지명; > package UI;
    * 다른 클래스에서 쓰려는 클래스를 import pacakagen.class 

  - 디폴트 패키지와 패키지의 특징
    * 디폴트 패키지
      - package 선언문 없이 만들어진 클래스의 패키지
      - 디폴트 패키지는 현재 디렉토리
    * 패키지의 특징
      - 패키지 계층 구조
        * 관련된 클래스 파일을 하나의 패키지로 계층화 하여 관리 용이
      - 패키지별로 접근 제한
      - 서로 다른 패키지에 이름이 같은 클래스와 인터페이스 존재 가능
      - 높은 소프트웨어 재사용성
  
  - 모듈
    * 의미 : 패키지와 이미지 등의 리소스를 담는 컨테이너
    * 모듈 파일(.jmod)로 저장

  - 자바 플랫폼의 모듈화
    * 자바 API의 모든 클래스가 여러 개의 모듈로 재구성됨
    * 모듈 파일은 JDK의 jmods 디렉토리에 저장하여 배포 

      ```cli
        jmod extract "dir"
      ```
  
  - 모듈 기반의 자바 실행 환경
    * JRE

  - 주요 패키지
    * java.lang > 자동으로 import, 나머지 아래의 패키지는 import 명시
    * java.util
    * java.io
    * java.awt
    * javax.swing

  - Object 클래스 
    * 모든 클래스의 수퍼 클래스
    * 모든 객체가 공통으로 가지는 객체의 속성을 나타내는 메소드 보유

    메소드 | 설명
    -- | --
    boolean equals(object obj) | ojb가 가리키는 객체와 현재 겍체를 비교하여 같으면 true 리턴
    Class getClass() | 현 객체의 런타임 클래스를 리턴
    int hashCode() | 현 객체에 대한 해시 코드 값 리턴
    String toString() | 현 객체에 대한 문자열 표현을 리턴
    void notify() | 현 객체에 대해 대기하고 있는 하나의 스레드를 깨운다.
    void notifyAll() | 현 객체에 대해 대기하고 있는 모든 스레드를 깨운다.
    void wait() | 다른 스레드가 깨울 때까지 현재 스레드를 대기하게 한다.

  - 객체 비교
    *  == : 레퍼런스를 비교
    * .equals() : 객체 내용을 비교

  - Wraaper 클래스
    * 기본 8 개 타입을 클래스화한 클래스 > 객체로 다룰 수 있게 해줌



--------------------------------------------------------------------------------

구현하려고 설계를 하는 것

설계자체가 목적이 되면 안됨

agile 개발방법론
  : 처음부터 완벽한 설계를 해서 설계한대로 구현하는것이 아니라, 완벽하지 않더라도 설계를 해서 구현한 후 다시 설계를 변경해서 다시 구현
  => 이 작업을 계속 반복하면서 완성해 나가는 개념

생성자 오버로딩시 참고사항
  1.파라미터가 있는 생성자를 만들면, 파라미터가 없는 기본 생성자를 컴파일러가 자동 생성하지 않는다. 
  2.생성자 오버로딩시에는 파라미터가 없는 기본생성자를 먼저 만들고 파라미터가 있는 생성자를 생성

upcasting을 활용하면
확장성 높은 Application을 구현할 수 있다.

spec 
  : 규격, standard